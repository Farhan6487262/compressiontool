# -*- coding: utf-8 -*-
"""finaltoolforcompression.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1x3jJJ0WnRICTzyCGFZI73i1tpl4Y4KcV
"""

# code is working, both options compressing files

import fitz  # PyMuPDF
import os
import subprocess
from google.colab import files
import time
from PIL import Image
import io

# Install Ghostscript in the Colab environment
!apt-get install -y ghostscript

# Function to compress PDF using Ghostscript (unchanged)
def compress_pdf_gs(input_pdf, output_pdf, quality='screen'):
    qualities = ['screen', 'ebook', 'printer', 'prepress']
    if quality not in qualities:
        raise ValueError(f"Invalid quality. Choose from: {qualities}")

    command = [
        "gs",
        "-sDEVICE=pdfwrite",
        "-dCompatibilityLevel=1.4",
        f"-dPDFSETTINGS=/{quality}",
        "-dNOPAUSE",
        "-dQUIET",
        "-dBATCH",
        f"-sOutputFile={output_pdf}",
        input_pdf
    ]

    try:
        subprocess.run(command, check=True, stderr=subprocess.PIPE)
    except subprocess.CalledProcessError as e:
        print(f"Ghostscript command failed with error: {e.stderr.decode()}")
        raise RuntimeError(f"Ghostscript compression failed. Error: {e.stderr.decode()}")

# Improved image compression function
def compress_images_in_pdf(doc, compression_type="less"):
    new_pdf = fitz.open()

    # Quality settings based on compression type
    if compression_type == "less":
        image_quality = 85  # Higher quality for "less" compression
        jpeg_quality = 90
    else:  # For cases where this might be called with other types
        image_quality = 50
        jpeg_quality = 75

    for page_num in range(doc.page_count):
        page = doc.load_page(page_num)
        image_list = page.get_images(full=True)

        # Create new page with original content
        new_page = new_pdf.new_page(width=page.rect.width, height=page.rect.height)

        # First add all non-image elements
        new_page.show_pdf_page(new_page.rect, doc, page_num)

        # Then process and compress images
        for img in image_list:
            xref = img[0]
            base_image = doc.extract_image(xref)
            image_bytes = base_image["image"]

            try:
                with Image.open(io.BytesIO(image_bytes)) as image:
                    # Convert to RGB if needed
                    if image.mode != 'RGB':
                        image = image.convert('RGB')

                    # Calculate new dimensions (less aggressive for "less")
                    width, height = image.size
                    if compression_type == "less":
                        new_width, new_height = width, height  # Keep original size
                    else:
                        new_width = int(width * 0.7)
                        new_height = int(height * 0.7)

                    # Resize and compress
                    image = image.resize((new_width, new_height), Image.LANCZOS)
                    buffer = io.BytesIO()
                    image.save(buffer, format="JPEG", quality=jpeg_quality)
                    compressed_image = buffer.getvalue()

                    # Insert compressed image
                    new_page.insert_image(page.rect, stream=compressed_image)
            except Exception as e:
                print(f"Error processing image: {e}")
                continue

    output_file = f"/content/{os.path.splitext(doc.name)[0]}_compressed_{compression_type}_{int(time.time())}.pdf"
    new_pdf.save(output_file, deflate=True)
    return output_file

# Improved main compression function
def compress_pdf(input_pdf, compression_type="less"):
    doc = fitz.open(input_pdf)

    if compression_type == "extreme":
        output_file = f"/content/{os.path.splitext(input_pdf)[0]}_compressed_extreme_{int(time.time())}.pdf"
        compress_pdf_gs(input_pdf, output_file, quality='screen')
        return output_file
    elif compression_type == "less":
        # For "less" compression, we'll use a combined approach
        if any(page.get_images(full=True) for page in doc):
            return compress_images_in_pdf(doc, "less")
        else:
            # For text PDFs, use Ghostscript with lighter settings
            output_file = f"/content/{os.path.splitext(input_pdf)[0]}_compressed_less_{int(time.time())}.pdf"
            compress_pdf_gs(input_pdf, output_file, quality='printer')  # Lighter compression
            return output_file
    else:
        print("Invalid compression type")
        return None

# Main function remains the same
def main():
    print("Please upload your PDF file.")
    uploaded = files.upload()
    file_path = next(iter(uploaded))
    print(f"File '{file_path}' uploaded successfully.")

    compression_type = input("Which compression do you want? ('less' or 'extreme'): ").strip().lower()
    compressed_file = compress_pdf(file_path, compression_type)

    if compressed_file:
        print(f"File compressed successfully: {compressed_file}")
        if os.path.exists(compressed_file):
            print(f"Downloading {compressed_file}...")
            files.download(compressed_file)
        else:
            print(f"Error: The file '{compressed_file}' does not exist.")
    else:
        print("Compression failed.")

if __name__ == "__main__":
    main()

from IPython.display import display
import ipywidgets as widgets
from google.colab import files
import fitz  # PyMuPDF
import os
import subprocess
import time
from PIL import Image
import io
import warnings

# Suppress warnings
warnings.filterwarnings("ignore")

# Install Ghostscript
!apt-get install -y ghostscript

# Compression Functions --------------------------------------------------------

def compress_pdf_gs(input_pdf, output_pdf, quality='screen'):
    """Compress PDF using Ghostscript"""
    qualities = ['screen', 'ebook', 'printer', 'prepress']
    if quality not in qualities:
        raise ValueError(f"Invalid quality. Choose from: {qualities}")

    command = [
        "gs",
        "-sDEVICE=pdfwrite",
        "-dCompatibilityLevel=1.4",
        f"-dPDFSETTINGS=/{quality}",
        "-dNOPAUSE",
        "-dQUIET",
        "-dBATCH",
        f"-sOutputFile={output_pdf}",
        input_pdf
    ]

    try:
        subprocess.run(command, check=True, stderr=subprocess.PIPE)
    except subprocess.CalledProcessError as e:
        raise RuntimeError(f"Ghostscript failed: {e.stderr.decode()}")

def compress_images_in_pdf(doc, compression_type="less"):
    """Compress images within PDF"""
    new_pdf = fitz.open()

    # Quality settings
    jpeg_quality = 85 if compression_type == "less" else 65
    resize_ratio = 1.0 if compression_type == "less" else 0.7

    for page_num in range(doc.page_count):
        page = doc.load_page(page_num)
        new_page = new_pdf.new_page(width=page.rect.width, height=page.rect.height)
        new_page.show_pdf_page(new_page.rect, doc, page_num)

        for img in page.get_images(full=True):
            try:
                xref = img[0]
                base_image = doc.extract_image(xref)
                image_bytes = base_image["image"]

                with Image.open(io.BytesIO(image_bytes)) as image:
                    # Convert to RGB if needed
                    if image.mode != 'RGB':
                        image = image.convert('RGB')

                    # Resize if needed
                    if resize_ratio < 1.0:
                        width, height = image.size
                        image = image.resize(
                            (int(width * resize_ratio), int(height * resize_ratio)),
                            Image.LANCZOS
                        )

                    # Compress and save
                    buffer = io.BytesIO()
                    image.save(buffer, format="JPEG", quality=jpeg_quality)
                    new_page.insert_image(page.rect, stream=buffer.getvalue())

            except Exception as e:
                print(f"Skipping image due to error: {e}")
                continue

    output_file = f"/content/compressed_{compression_type}_{int(time.time())}.pdf"
    new_pdf.save(output_file, deflate=True)
    return output_file

def compress_pdf(input_pdf, compression_type="less"):
    """Main compression function"""
    doc = fitz.open(input_pdf)

    if compression_type == "extreme":
        output_file = f"/content/compressed_extreme_{int(time.time())}.pdf"
        compress_pdf_gs(input_pdf, output_file, 'screen')
    elif compression_type == "less":
        if any(page.get_images(full=True) for page in doc):
            output_file = compress_images_in_pdf(doc, "less")
        else:
            output_file = f"/content/compressed_less_{int(time.time())}.pdf"
            compress_pdf_gs(input_pdf, output_file, 'printer')
    else:
        raise ValueError("Invalid compression type")

    return output_file

# UI with ipywidgets ----------------------------------------------------------

# Create widgets
upload = widgets.FileUpload(accept='.pdf', multiple=False, description="PDF File:")
compression_type = widgets.RadioButtons(
    options=['less', 'extreme'],
    value='less',
    description='Compression:',
    style={'description_width': 'initial'}
)
compress_btn = widgets.Button(description="Compress PDF", button_style='success')
output = widgets.Output()

# Style the UI
box_layout = widgets.Layout(display='flex', flex_flow='column', align_items='stretch', width='70%')
header = widgets.HTML("<h2>PDF Compression Tool</h2>")

# Compression function
def on_compress_click(b):
    with output:
        output.clear_output()

        if not upload.value:
            print("⚠️ Please upload a PDF file first")
            return

        # Get uploaded file
        file_name = next(iter(upload.value))
        file_content = upload.value[file_name]['content']

        # Save temporarily
        temp_path = f"/content/{file_name}"
        with open(temp_path, 'wb') as f:
            f.write(file_content)

        # Show original size
        original_size = os.path.getsize(temp_path) / (1024 * 1024)  # in MB
        print(f"📄 Original file: {file_name} ({original_size:.2f} MB)")
        print(f"🔧 Compression: {compression_type.value}")
        print("⏳ Processing...")

        try:
            # Compress
            start_time = time.time()
            compressed_path = compress_pdf(temp_path, compression_type.value)

            if compressed_path and os.path.exists(compressed_path):
                # Show results
                new_size = os.path.getsize(compressed_path) / (1024 * 1024)
                ratio = (1 - (new_size / original_size)) * 100
                time_taken = time.time() - start_time

                print(f"\n✅ Compression successful!")
                print(f"📊 Results:")
                print(f"  Original: {original_size:.2f} MB")
                print(f"  Compressed: {new_size:.2f} MB")
                print(f"  Reduction: {ratio:.1f}%")
                print(f"  Time: {time_taken:.1f} seconds")

                # Download
                print("\n⬇️ Downloading compressed file...")
                files.download(compressed_path)
            else:
                print("❌ Compression failed")

        except Exception as e:
            print(f"❌ Error: {str(e)}")
        finally:
            # Clean up
            if os.path.exists(temp_path):
                os.remove(temp_path)

compress_btn.on_click(on_compress_click)

# Display the UI
display(widgets.VBox([
    header,
    upload,
    compression_type,
    compress_btn,
    output
], layout=box_layout))